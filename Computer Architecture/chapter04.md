# 중앙 처리 장치
## 프로세서 구성과 동작
<img src="https://user-images.githubusercontent.com/60968342/130899640-7166ced7-c79e-4a8e-9cfe-b370355f8dda.jpg">

프로세서의 필수 요소 세 가지는 **산술 논리 연산 장치(ALU), 제어 장치(CU), 레지스터 세트(Register Set)** 이다.
- ALU: 산술 및 논리 연산 등 기본 연산을 수행한다.
- CU: 메모리에서 명령어를 가져와 해독하고 실행에 필요한 장치들을 제어하는 신호를 발생시킨다.
- Register: ALU의 연산과 관련된 데이터를 일시 저장하거나 특정 제어 정보를 저장한다. 프로세서가 가진 다양한 레지스터를 통칭하여 레지스터 세트라고 한다. 일반적으로 레지스터들은 크기가 모두 동일하며, 기능이 정해져 있다. 각 레지스터는 하나의 값을 저장할 수 있으며, 프로세서 내부에 있으므로 고속으로 읽고 쓸 수 있다. 대표적으로 다음 실행할 명령의 주소를 저장하고 있는 **프로그램 카운터(PC)** 와 현재 실행 중인 명령을 가진 **명령 레지스터(IR)** 이 있다.

### 프로세서 기본 구조
ALU를 이용하여 오퍼랜드를 실행하고 결과를 저장하는 부분을 **데이터 경로** 라 하며 CPU의 핵심이다.
<img src="https://user-images.githubusercontent.com/60968342/130899655-84c98dcc-9c0c-48ac-bc1e-23ec8561d182.jpg">

ALU는 입력에 대해 덧셈, 뺄셈 등 연산을 수행하고, 그 결과를 누산기(AC)에 저장한다. 대부분의 명령은 다음 두 가지 범주 중 하나로 분류할 수 있다.
- 레지스터-메모리 명령   
  메모리 워드를 레지스터로 가져올 수 있으며(LOAD), 바로 이어지는 명령에서 레지스터의 내용을 ALU의 입력으로 사용할 수 있다. 다른 레지스터-메모리 명령을 사용하면 레지스터를 메모리에 다시 저장(STORE)할 수 있다.
- 레지스터-레지스터 명령

### 프로세서 명령 실행
프로세서는 각 명령을 더 작은 **마이크로 명령 단계(microinstruction)**로 나누어 실행한다.
1. 다음에 실행할 명령어를 메모리에서 읽어 명령 레지스터(IR)로 가져온다.
2. 프로그램 카운터(PC)는 그 다음에 읽어올 명령어의 주소로 변경된다.
3. 제어 장치는 방금 가져온 명령어를 해독(decode)하고 유형을 결정한다.
4. 명령어가 메모리에 있는 데이터를 사용하는 경우 그 위치를 결정한다.
5. 필요한 경우 데이터를 메모리에서 레지스터로 가져온다.
6. 명령어를 실행한다.
7. 1단계로 이동하여 다음 명령어 실행을 시작한다.

이 단계를 요약하면 **인출(fetch)-해독(decode)-실행(execute)** 사이클로 구성되며, 이를 주 사이클이라고 한다.

## 산술 논리 연산 장치
일반적으로 ALU는 주로 정수 연산을 처리하지만 최근에는 부동 소수 연산까지 처리하기도 한다. 명령어에 따라 산술 연산이나 논리 연산 중 하나를 실행한다.

### 산술 연산
다음 산술 연산은 가산기(adder)를 기반으로 동작한다.

| 연산 | 동작 | 설명 |
|--|--|--|
| ADD | X ← A + B | A와 B를 더한다 |
| SUB | X ← A + (~B + 1) | A + (B의 2의 보수) |
| MUL | X ← A * B | A와 B를 곱한다 |
| DIV | X ← A / B | A와 B를 나눈다 |
| INC | X ← A + 1 | A를 1 증가시킨다 |
| DEC | X ← A - 1(0xFF) | A를 1 감소시킨다 |
| NEG | X ← ~A + 1 | A의 2의 보수다 |

실제 회로에서는 캐리 전파로 일어나는 속도 지연 문제 때문에 덧셈 회로에 전가산기(FA) 대신 캐리 예측 가산기를 사용하기도 한다.

곱셈의 경우 부스(Booth) 알고리즘을 사용한다.

<img src="https://user-images.githubusercontent.com/60968342/130899669-598da29e-c090-4ed7-9279-de9c01b2d96c.png">

## 레지스터
CPU 내부에서 처리할 명령어나 연산의 중간값들을 일시적으로 저장하는 기억장치이다. CPU가 사용하는 데이터와 명령어를 신속하게 읽어 오고 저장하고 전송하는 데 사용된다. 레지스터는 **메모리 계층의 최상위**에 있으며 **시스템에서 가장 빠른 메모리**이다.

<img src="https://user-images.githubusercontent.com/60968342/130899681-66bef2d9-950a-4b09-a1f8-7a5420459a3d.jpg">

### 레지스터 종류
레지스터는 CPU에서 중요한 구성 요소로 특정 기능을 수행한다.

- **메모리 주소 레지스터(MAR)**: CPU가 읽고 쓰기 위한 데이터의 메모리 주소를 저장한다. CPU는 메모리에 데이터를 저장하거나 메모리에서 데이터를 읽을 때 필요한 메모리 위치의 주소를 MAR로 보낸다.
- **메모리 버퍼 레지스터(MBR)**: 메모리에서 데이터를 읽거나 메모리에 저장될 명령의 데이터를 일시적으로 가지고 있다. 임시 저장된 명령어 내용은 명령 레지스터로 전송, 데이터 내용은 누산기 또는 I/O 레지스터로 전송된다.
- **프로그램 카운터(PC)**: 명령 포인터 레지스터라고도 하며, 실행을 위해 인출(fetch)할 다음 명령의 주소를 저장하는 데 사용된다. 명령어가 인출되면 PC 값이 단위 길이(명령 크기)만큼 증가한다. 따라서 이 레지스터는 **항상 가져올 다음 명령의 주소를 가리키거나 유지한다.**
- **명령 레지스터(IR)**: 주기억 장치에서 인출한 명령어를 저장한다. 제어 장치는 IR에서 명령어를 읽어와서 해독하고 명령을 수행하기 위해 컴퓨터의 각 장치에 제어 신호를 전송한다.
- **누산기(AC)**: ALU 내부에 위치하며, ALU의 산술 연산과 논리 연산 과정에 사용한다. 제어 장치는 주기억 장치에서 인출된 데이터 값을 산술 연산 또는 논리 연산을 위해 누산기에 저장한다.

### 📌 레지스터 전송?
- LOAD: 주기억 장치에서 레지스터로 데이터를 읽어 옴.
- STORE: 레지스터에서 주기억 장치로 데이터를 저장.
- MOVE: 레지스터에서 레지스터로 데이터를 이동.

## 컴퓨터 명령어
명령어는 **연산 코드(opcode, 행위/동작/지시)**와 **오퍼랜드(operand, 피연산자) 위치**, 연산 결과의 저장 위치 등 여러가지 정보로 구성된다.

<img src="https://user-images.githubusercontent.com/60968342/130899700-ab2d8e7d-6447-422b-b6e6-6be565aae5ae.png">

- 0-주소 명령어: 연산에 필요한 오퍼렌드와 결과의 저장 장소가 모두 묵시적으로 지정된 경우로, 스택을 갖는 구조에서 사용된다. 데이터를 기억시킬 때는 PUSH를, 꺼낼 때는 POP을 사용한다.
- 1-주소 명령어: 연산 대상이 되는 2개 중 하나만 표현하고 나머지 하나는 묵시적으로 지정된 누산기(AC)를 사용한다. 기억 장치 내의 데이터와 AC 내의 데이터로 연산이 이루어지고 연산 결과는 AC에 저장된다.    
`ADD X ; AC ← AC + M[X]`
- 2-주소 명령어: 연산에 필요한 두 오퍼랜드의 저장 장소 중 하나가 결과 값을 저장하는 장소로 사용한다.       
`ADD R1, R2  ; R1 ← R1 + R2`
- 3-주소 명령어: 연산에 필요한 오퍼랜드 2개와 결과 값의 저장 장소가 모두 달라 명령어에 주소 3개를 모두 지정한다. 연산 후에도 입력 데이터가 변하지 않고 보존되는 특징이 있다. 프로그램의 길이가 짧아지는 장점이 있으나, 명령어 해독 과정이 복잡해지는 단점도 있다.      
`ADD R1, R2, R3  ; R1 ← R2 + R3`

## 주소 지정 방식
대부분의 명령어에는 오퍼랜드가 있으며, 오퍼랜드 위치를 지정하는 것을 주소 지정이라고 한다.

### 📌 참고 사항
- 컴퓨터에서의 주소는 기억 장치의 위치 값을 의미하며 실제 데이터가 기억되어 있는 위치를 나타낸다.
- 주기억장치 데이터가 저장되는 고유 위치가 있으며, 그 위치를 절대주소라고 하며, 프로그래밍 언어에선 포인터로 사용된다.
- 프로그래밍 언어에서 `a = 30`은 변수 a에 상수 30을 기억시키는 명령

### 즉시 주소 지정
명령어에 오퍼랜드가 포함되어 명령어가 인출될 때 오퍼랜드도 자동으로 인출되고 이 값도 즉시 사용할 수 있는 주소 지정이다. 메모리 참조 횟수가 0인 장점이 있지만, **상수**만 가능하며 상수 값의 크기가 필드 크기로 제한된다는 단점이 있다.

<img src="https://user-images.githubusercontent.com/60968342/130899714-ac06e46f-7626-4a5f-96de-af60ef9b1083.jpg">

### 직접 주소 지정
메모리에 위치한 오퍼랜드를 지정하는 방법은 전체 주소를 지정하는 것이며, 이를 직접 주소 지정이라 한다. 명령어는 항상 정확히 동일한 메모리 위치에 액세스 한다. 값이 변할 수는 있으나 위치는 변할 수 없다. 따라서 이 방식은 컴파일할 때 알려진 주소의 전역 변수에 액세스하는 데만 사용할 수 있다.

<img src="https://user-images.githubusercontent.com/60968342/130899812-86cb7ab6-661a-4880-90c7-9de01dd5657d.jpg">

### 레지스터 간접 주소 지정
지정된 오퍼랜드는 메모리에서 가져오거나 메모리로 이동하는 기능은 같지만 직접 주소를 명령어에는 포함하지는 않는다. 그 대신 메모리의 주소는 레지스터에 저장되어 있고, 이 주소를 **포인터(pointer)**라고 한다. 이 방식의 가장 큰 **장점은 명령어에 전체 메모리 주소가 없어도 메모리를 참조할 수 있다는 것이다.**

<img src="https://user-images.githubusercontent.com/60968342/130899815-2751f031-c839-4468-9737-b7b0f48bb3c4.jpg">

### 변위 주소 지정
특정 레지스터에 저장된 주소에 변위(offset)을 더해 실제 오퍼랜드가 저장된 메모리 위치를 지정하는 방식이다. 인덱스 주소 지정 방식은 인덱스 레지스터가 되고, 상대 주소 지정 방식에서는 PC가 특정 레지스터가 된다.

<img src="https://user-images.githubusercontent.com/60968342/130899825-5eb17a1d-31fe-490e-9390-9e0e471b716e.jpg">

### 간접 주소 지정
메모리 참조가 두 번 이상 일어나는 경우이다. 데이터를 가져오는 데 많은 시간이 걸린다. 현재는 이와 같은 방식을 지원하는 프로세서가 없다고 보면 된다.
